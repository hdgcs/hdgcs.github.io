---
title:  '一次写对二分查找'
tags:   [LeetCode, Search, Algorithm]
---

二分查找是一种常见的查找算法，他能在有序数组里以 O(logn) 时间复杂度完成查找，是一种很值得掌握的算法。二分查找基本原理很简单，难的是细节处理，第一个二分查找出现在 1946 年，但完全正确的版本直到 1962 年才出现。

我刷了约40多道二分查找题后，总结出了这些经验，希望他们也能帮助到你。

## 完善细节的基础版本

先上一个最简单的二分查找：

```java
// 在递增不重复的数组 nums 中查找值为 target 的下标，不存在则返回 -1
public int bsearch(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
```

上面的版本是最直观最容易写出来的，实际上任何复杂的版本都是基于上面这个，所有复杂版本的分析只要基于这个就行了，简单吧？

当然居然是完善细节的版本，上面有一个还不够健壮的地方，需要改进下：

```java
// 改进前
int mid = (low + high) / 2;

// 改进后
int mid = low + ((high - low) >> 1);
```

因为任何数据都需要考虑边界范围，用减法替代加法就不会出现溢出的 bug 了。另外位运算比乘除有性能提升，因此这里也优化了一下，当然你如果不习惯位操作，那只处理溢出问题就足够了。

## 二分查找具体要素

上面说了所有复杂版本都是基于上面的基础版本，下面直接根据基础版本总结出下列五个要素。以后遇到二分查找，直接问自己这五个要素是啥，然后依葫芦画瓢代码就出来了。

### 1. 终止条件

```java
// 终止条件
while (low <= high) {
}
```

基础版本用的是 `<=`，实际上还有 `<` 的情况。那什么时候用 `<` 呢？

我们先想下基础版本为啥可以等于，回顾一下代码可以发现每次循环处理中，收缩区间时都不会出现等于 `mid` 的情况，但有些场景是不能排除 `mid` 的，这时候会出现最后两个数死循环的问题，需要把终止条件改用 `<` 解决。

具体可以跟下面的其他要素一起看。

### 2. 取二分点

```java
// 取二分点
int mid = low + ((high - low) >> 1);
```

认真分析一下这个取二分点的代码，实际上可以发现他是靠小取二分点，就是说如果中间有两个数时取的是较小的数。

既然可以靠小取，那就肯定存在靠大取。我的总结是：收缩区间时哪边能排除 mid 值就可以往哪边取。

举个例子：

```java
if (f(x) < target) {
    low = mid;
// 大边界不需要考虑 mid 情况
} else {
    high = mid - 1;
}
```

这种就应该在取二分点时选择靠大取。最后给出一下靠大取二分点的代码：

```java
int mid = low + ((high - low + 1) >> 1);
```

为啥 `+1` 就能靠大取，怎么记？因为除数是2，加上一个比除数小 1 的数即会靠大取。

### 3. 收缩区间

```java
// 收缩区间
if (nums[mid] < target) {
    low = mid + 1;
} else {
    high = mid - 1;
}
```

上面两个要素里也大致提过收缩区间，这里详细深入讲一下了，这里主要要处理“收缩是否要包含 mid”。一般有两种常见案例：

- 如果要找第一个大于 num 的元素，收缩大边界时就要包含 mid
- 如果要找最后一个小于 num 的元素，收缩小边界时就要包含 mid

当然还有很多其他需求场景，实际上核心就是找到的 mid 是不是有可能成为答案，判断时可以在纸上自己举例推演。

### 4. 返回值选择

```java
// 返回值选择
while (xxx) {
    if (nums[mid] == target) return mid;
}
return -1;
```

基础版本的返回值选择有两个地方：
1. 循环体处理时找到答案
2. 循环体退出时返回没找到

分析上面两个可以发现基础版本是一定能

### 5. 复杂 f(x)

## 案例实战

## 总结

二分查找场景较为苛刻，要求数据为顺序表结构，因此只适合没有增删操作的静态数据场景，因此大部分场景下我们都会用哈希表和二叉树查找代替二分查找。
但是有一种场景下仍然很适合使用二分查找，那就是近似

